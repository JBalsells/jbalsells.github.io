<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Física del Rescate — Camilla en Tirolesa</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&family=Roboto:wght@300;400;500;700&display=swap">
  <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/font-awesome/css/all.min.css" rel="stylesheet">
  <link href="../css/main.css" rel="stylesheet">
  <style>
    .sim-content *, .sim-content *::before, .sim-content *::after { box-sizing: border-box; margin: 0; padding: 0; }


    h1 {
      font-size: 1.45rem;
      color: #00BCD4;
      text-align: center;
      margin-bottom: 4px;
      letter-spacing: 0.4px;
    }

    .subtitle {
      font-size: 0.82rem;
      color: #FFC107;
      text-align: center;
      margin-bottom: 3px;
      font-style: italic;
    }

    .subtitle2 {
      font-size: 0.74rem;
      color: #78909C;
      text-align: center;
      margin-bottom: 12px;
      font-style: italic;
    }

    .main-layout {
      display: flex;
      gap: 12px;
      width: 100%;
      max-width: 1380px;
      align-items: flex-start;
    }

    .left-col {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }

    canvas {
      display: block;
      border-radius: 6px;
      border: 1px solid #143045;
      background: #061520;
    }

    /* Controls below the canvas area */
    .controls-box {
      background: #0a1e2f;
      border: 1px solid #143045;
      border-radius: 8px;
      padding: 12px 18px;
      display: flex;
      flex-direction: column;
      gap: 9px;
    }

    .slider-row {
      display: grid;
      grid-template-columns: 210px 1fr 90px;
      align-items: center;
      gap: 10px;
    }

    .slider-label { font-size: 0.85rem; text-align: right; color: #ECEFF1; }

    input[type="range"] {
      width: 100%;
      cursor: pointer;
      height: 5px;
      border-radius: 3px;
    }

    .slider-val {
      font-size: 0.92rem;
      font-weight: bold;
      font-variant-numeric: tabular-nums;
    }

    #slSpan  { accent-color: #00BCD4; }
    #slSag   { accent-color: #FF5722; }
    #slMass  { accent-color: #4CAF50; }
    #slPos   { accent-color: #FFC107; }

    #valSpan { color: #00BCD4; }
    #valSag  { color: #FF5722; }
    #valMass { color: #4CAF50; }
    #valPos  { color: #FFC107; }

    .btn-row {
      display: flex;
      gap: 12px;
      margin-top: 4px;
    }

    button {
      padding: 7px 20px;
      border: none;
      border-radius: 5px;
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.08s;
    }

    button:active { transform: scale(0.96); }

    #btnAuto {
      background: #1a3a4a;
      color: #00BCD4;
      border: 1px solid #00BCD4;
    }

    #btnAuto.active {
      background: #00BCD4;
      color: #061520;
    }

    #btnReset {
      background: #1e1e30;
      color: #ECEFF1;
      border: 1px solid #143045;
    }

    #btnReset:hover { background: #2a2a40; }

    /* Right panel */
    .right-panel {
      width: 320px;
      flex-shrink: 0;
      background: #0a1e2f;
      border: 1px solid #00BCD4;
      border-radius: 8px;
      padding: 14px 14px 14px 14px;
      display: flex;
      flex-direction: column;
      gap: 0;
      font-size: 0.82rem;
      min-height: 700px;
    }

    .panel-heading {
      color: #00BCD4;
      font-weight: bold;
      font-size: 0.88rem;
      margin-bottom: 5px;
      margin-top: 4px;
      letter-spacing: 0.5px;
    }

    .panel-sep {
      border: none;
      border-top: 1px solid #143045;
      margin: 8px 0;
    }

    .panel-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      line-height: 1.4;
    }

    .panel-row .key { color: #78909C; }
    .panel-row .val { font-weight: bold; font-variant-numeric: tabular-nums; }

    /* Progress bars */
    .bar-wrap {
      margin-bottom: 8px;
    }

    .bar-label-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.78rem;
      margin-bottom: 2px;
    }

    .bar-track {
      background: #1e1e35;
      border-radius: 4px;
      height: 10px;
      position: relative;
      overflow: visible;
    }

    .bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.05s, background 0.05s;
    }

    .bar-mark {
      position: absolute;
      top: -2px;
      height: 14px;
      width: 2px;
      background: #FFC107;
    }

    .bar-mark-mbs {
      position: absolute;
      top: -2px;
      height: 14px;
      width: 2px;
      background: #F44336;
    }

    .status-box {
      border-radius: 5px;
      padding: 6px 10px;
      font-size: 0.8rem;
      font-weight: bold;
      margin-bottom: 4px;
      text-align: center;
    }

    .concepts {
      font-size: 0.76rem;
      color: #78909C;
      line-height: 1.6;
      margin-top: 4px;
    }

    .concepts b { color: #FFC107; }

    .footer {
      margin-top: 14px;
      font-size: 0.72rem;
      color: #78909C;
      font-style: italic;
      text-align: center;
      max-width: 1380px;
    }

  
    /* ─── Simulation content panel ───────────────────────────────────── */
    .sim-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 8px 24px;
      background: #061520;
      border-radius: 8px;
      color: #ECEFF1;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      overflow-x: auto;
    }

    /* ─── Back button ─────────────────────────────────────────────────── */
    .btn-back {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.42rem 1.1rem;
      margin-bottom: 1.2rem;
      border-radius: 999px;
      font-size: 0.82rem;
      font-weight: 500;
      letter-spacing: 0.03em;
      color: var(--color-primary);
      background: var(--color-primary-light);
      border: 1.5px solid var(--color-primary-medium);
      text-decoration: none;
      transition: background 0.18s, color 0.18s, transform 0.15s,
                  box-shadow 0.18s, border-color 0.18s;
    }
    .btn-back:hover {
      background: var(--color-primary);
      color: #fff;
      border-color: var(--color-primary);
      transform: translateX(-3px);
      box-shadow: 0 4px 16px rgba(26, 79, 100, 0.25);
      text-decoration: none;
    }
    .btn-back-arrow {
      font-size: 0.72rem;
      transition: transform 0.18s;
    }
    .btn-back:hover .btn-back-arrow {
      transform: translateX(-3px);
    }
  </style>
  <script>(function(){var t=localStorage.getItem('theme');if(t)document.documentElement.setAttribute('data-theme',t);})();</script>
</head>
<body id="top">
  <!-- Scroll progress bar -->
  <div class="scroll-progress d-print-none" id="scrollProgress"></div>

  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark sticky-nav d-print-none">
    <div class="container">
      <a class="navbar-brand" href="../index.html">Jorge A. Balsells Orellana</a>
      <div class="d-flex align-items-center ms-auto d-lg-none">
        <button class="btn btn-link nav-dark-toggle me-2" id="darkToggleMobile" aria-label="Toggle dark mode">
          <i class="fas fa-moon"></i>
        </button>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarMain" aria-controls="navbarMain" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      </div>
      <div class="collapse navbar-collapse" id="navbarMain">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item"><a class="nav-link" href="../index.html#about">About</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#skills">Skills</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#experience">Experience</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#education">Education</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#certs">Courses</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#projects">Projects</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#volunteer">Volunteering</a></li>
          <li class="nav-item"><a class="nav-link" href="../gallery.html">Gallery</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle active" href="#" id="othersDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Others
            </a>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="othersDropdown">
              <li><a class="dropdown-item" href="../rope_simulations.html">Rope Simulations</a></li>
            </ul>
          </li>
          <li class="nav-item nav-contact-pill"><a class="nav-link" href="../index.html#contact"><i class="fas fa-envelope me-1"></i>Contact</a></li>
          <li class="nav-item d-none d-lg-block">
            <button class="btn btn-link nav-dark-toggle" id="darkToggleDesktop" aria-label="Toggle dark mode">
              <i class="fas fa-moon"></i>
            </button>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="page-content">
    <div class="container">
      <div class="cover shadow-sm">
        <div class="px-3 px-lg-4 py-4">
          <a href="../rope_simulations.html" class="btn-back"><i class="fas fa-chevron-left btn-back-arrow"></i> Rope Simulations</a>
          <h2 class="section-heading"><i class="fas fa-arrows-alt-h"></i>Camilla en Tirolesa</h2>
          <div class="sim-content">



<h1>TIROLESA — Paso de Camilla con Análisis de Fuerzas</h1>
<p class="subtitle">H = W·x·(L−x)/(d·L) &nbsp;&nbsp; T = H/cos(α) &nbsp;&nbsp; Ángulo V = 180° − α<sub>L</sub> − α<sub>R</sub></p>
<p class="subtitle2">La flecha real de la cuerda cambia según la posición de la carga (cuerda inextensible de longitud fija)</p>

<div class="main-layout">

  <!-- LEFT COLUMN: canvases + controls -->
  <div class="left-col">

    <!-- Scene canvas -->
    <canvas id="sceneCanvas" width="840" height="300"></canvas>

    <!-- Graphs canvas -->
    <canvas id="graphCanvas" width="840" height="210"></canvas>

    <!-- Controls -->
    <div class="controls-box">

      <div class="slider-row">
        <label class="slider-label" for="slSpan">Vano L (m):</label>
        <input type="range" id="slSpan" min="10" max="100" step="1" value="30">
        <span class="slider-val" id="valSpan">30 m</span>
      </div>

      <div class="slider-row">
        <label class="slider-label" for="slSag">Flecha central (%):</label>
        <input type="range" id="slSag" min="0.5" max="25" step="0.5" value="5">
        <span class="slider-val" id="valSag">5.0 %</span>
      </div>

      <div class="slider-row">
        <label class="slider-label" for="slMass">Masa (kg):</label>
        <input type="range" id="slMass" min="10" max="300" step="1" value="100">
        <span class="slider-val" id="valMass">100 kg</span>
      </div>

      <div class="slider-row">
        <label class="slider-label" for="slPos">Posición carga (%):</label>
        <input type="range" id="slPos" min="0" max="100" step="0.5" value="50">
        <span class="slider-val" id="valPos">50 %</span>
      </div>

      <div class="btn-row">
        <button id="btnAuto">&#9654; Auto-travesía</button>
        <button id="btnReset">&#10227; Reiniciar</button>
      </div>

    </div><!-- .controls-box -->
  </div><!-- .left-col -->

  <!-- RIGHT PANEL -->
  <div class="right-panel" id="rightPanel">

    <div class="panel-heading">PARÁMETROS DEL SISTEMA</div>
    <div class="panel-row">
      <span class="key">Vano (L):</span>
      <span class="val" id="pSpan" style="color:#00BCD4">30 m</span>
    </div>
    <div class="panel-row">
      <span class="key">Flecha centro:</span>
      <span class="val" id="pSag" style="color:#FFC107">1.50 m (5.0%)</span>
    </div>
    <div class="panel-row">
      <span class="key">Carga:</span>
      <span class="val" id="pMass" style="color:#F44336">100 kg (0.98 kN)</span>
    </div>
    <div class="panel-row">
      <span class="key">Posición:</span>
      <span class="val" id="pPos">15.0 m (50%)</span>
    </div>

    <hr class="panel-sep">

    <div class="panel-heading">ÁNGULOS</div>
    <div class="panel-row">
      <span class="key">α izquierdo:</span>
      <span class="val" id="pAlphaL">—</span>
    </div>
    <div class="panel-row">
      <span class="key">α derecho:</span>
      <span class="val" id="pAlphaR">—</span>
    </div>
    <div class="panel-row" style="margin-top:4px">
      <span class="key" style="font-weight:bold">Ángulo V:</span>
      <span class="val" id="pVangle" style="font-size:1rem">—</span>
    </div>
    <div class="status-box" id="vStatus">—</div>

    <hr class="panel-sep">

    <div class="panel-heading">TENSIONES</div>
    <div class="panel-row">
      <span class="key">H (horizontal):</span>
      <span class="val" id="pH" style="color:#2196F3">—</span>
    </div>

    <div class="bar-wrap">
      <div class="bar-label-row">
        <span style="color:#6ab0ff">T izquierdo</span>
        <span class="val" id="pTL" style="color:#6ab0ff">—</span>
      </div>
      <div class="bar-track" id="barTLtrack">
        <div class="bar-fill" id="barTL" style="width:0%"></div>
        <div class="bar-mark" id="markNFPA_L"></div>
        <div class="bar-mark-mbs" id="markMBS_L"></div>
      </div>
    </div>

    <div class="bar-wrap">
      <div class="bar-label-row">
        <span style="color:#ffa050">T derecho</span>
        <span class="val" id="pTR" style="color:#ffa050">—</span>
      </div>
      <div class="bar-track" id="barTRtrack">
        <div class="bar-fill" id="barTR" style="width:0%"></div>
        <div class="bar-mark" id="markNFPA_R"></div>
        <div class="bar-mark-mbs" id="markMBS_R"></div>
      </div>
    </div>

    <hr class="panel-sep">

    <div class="panel-heading">SEGURIDAD</div>
    <div class="status-box" id="nfpaStatus">—</div>
    <div class="status-box" id="fsStatus">—</div>
    <div class="status-box" id="vagStatus">—</div>
    <div class="panel-row" style="margin-top:4px">
      <span class="key">Flecha mín. NFPA:</span>
      <span class="val" id="pSagMin" style="color:#2196F3">—</span>
    </div>

    <hr class="panel-sep">

    <div class="panel-heading" style="color:#FFC107">CONCEPTOS CLAVE</div>
    <div class="concepts">
      La carga en el <b>CENTRO</b> genera la máxima tensión en <b>AMBOS</b> anclajes (peor caso).<br><br>
      Con carga fuera del centro: <b>T_izq ≠ T_der</b>. La componente H es <b>igual</b> en ambos lados.<br><br>
      Ángulo V amplio = mayor multiplicación de fuerza (igual que anclaje en V).<br><br>
      <b>NUNCA</b> tensar la tirolesa "bien bonita". Más flecha = menos fuerza = más seguro.
    </div>

  </div><!-- .right-panel -->

</div><!-- .main-layout -->

<p class="footer">
  Física del Rescate · Módulo 11 — Camilla en Tirolesa · HTML5 Canvas · Sin dependencias externas
</p>

<script>
// ════════════════════════════════════════════════════════════════════════
//  CONSTANTES
// ════════════════════════════════════════════════════════════════════════
const G            = 9.81;
const NFPA         = 13.5;   // kN
const ROPE_MBS     = 30.0;   // kN
const PROFILE_N    = 80;
const TRAVERSE_SPD = 0.15;   // ratio/s

// Paleta
const C = {
  bg:        '#061520',
  panel:     '#0a1e2f',
  primary:   '#00BCD4',
  secondary: '#FF5722',
  accent:    '#4CAF50',
  warning:   '#FFC107',
  danger:    '#F44336',
  info:      '#2196F3',
  text:      '#ECEFF1',
  grid:      '#143045',
  rope:      '#FFA726',
  anchor:    '#78909C',
};
const COL_TL  = '#6ab0ff';
const COL_TR  = '#ffa050';
const COL_AL  = '#6ab0ff';
const COL_AR  = '#ffa050';
const COL_V   = '#b478ff';
const COL_ARR = '#6ab0ff';   // tension arrows

// ════════════════════════════════════════════════════════════════════════
//  FÍSICA
// ════════════════════════════════════════════════════════════════════════

function computeRopeLength(span, dCenter) {
  const half = span / 2.0;
  return 2.0 * Math.sqrt(half * half + dCenter * dCenter);
}

function solveSagAt(x, span, ropeLen) {
  if (x < 0.02 * span || x > 0.98 * span) return 0.001;
  let lo = 0.0001, hi = ropeLen * 0.5;
  for (let i = 0; i < 64; i++) {
    const mid = (lo + hi) * 0.5;
    const s = Math.sqrt(x * x + mid * mid) + Math.sqrt((span - x) ** 2 + mid * mid);
    if (s < ropeLen) lo = mid; else hi = mid;
  }
  return (lo + hi) * 0.5;
}

function computeForces(x, span, d, massKg) {
  const W = massKg * G / 1000.0;
  x = Math.max(0.01 * span, Math.min(x, 0.99 * span));
  const alphaL = Math.atan2(d, x);
  const alphaR = Math.atan2(d, span - x);
  const H = (d > 0.001) ? W * x * (span - x) / (d * span) : 0.0;
  const cosL = Math.cos(alphaL);
  const cosR = Math.cos(alphaR);
  const TL = (cosL > 1e-6) ? H / cosL : 999.0;
  const TR = (cosR > 1e-6) ? H / cosR : 999.0;
  const vAngle = 180.0 - (alphaL * 180 / Math.PI) - (alphaR * 180 / Math.PI);
  return { W, H, TL, TR, alphaLDeg: alphaL * 180 / Math.PI, alphaRDeg: alphaR * 180 / Math.PI, vAngle, d, x };
}

// ════════════════════════════════════════════════════════════════════════
//  COLOR HELPERS
// ════════════════════════════════════════════════════════════════════════

function safetyColor(vAngle) {
  if (vAngle > 160) return C.danger;
  if (vAngle > 140) return C.secondary;
  if (vAngle > 120) return C.warning;
  return C.accent;
}

function tensionColor(t) {
  if (t > ROPE_MBS)      return C.danger;
  if (t > NFPA)          return C.secondary;
  if (t > NFPA * 0.7)    return C.warning;
  return C.accent;
}

// ════════════════════════════════════════════════════════════════════════
//  STATE
// ════════════════════════════════════════════════════════════════════════

const state = {
  spanM:       30,
  sagPct:      5,
  massKg:      100,
  loadPos:     0.5,     // 0..1
  autoTraverse: false,
  traverseDir: 1,
  profile:     null,    // precomputed arrays
};

function rebuildProfile() {
  const L    = state.spanM;
  const dC   = L * state.sagPct / 100.0;
  const S    = computeRopeLength(L, dC);
  state._ropeLen  = S;
  state._dCenter  = dC;

  const TLarr = [], TRarr = [], Varr = [], darr = [], ALarr = [], ARarr = [];
  for (let i = 0; i < PROFILE_N; i++) {
    const ratio = (i + 0.5) / PROFILE_N;
    const x = ratio * L;
    const d = solveSagAt(x, L, S);
    const f = computeForces(x, L, d, state.massKg);
    TLarr.push(f.TL);
    TRarr.push(f.TR);
    Varr.push(f.vAngle);
    darr.push(f.d);
    ALarr.push(f.alphaLDeg);
    ARarr.push(f.alphaRDeg);
  }
  state.profile = { TL: TLarr, TR: TRarr, V: Varr, d: darr, AL: ALarr, AR: ARarr };
}

function currentForces() {
  const L = state.spanM;
  const x = state.loadPos * L;
  const d = solveSagAt(x, L, state._ropeLen);
  return computeForces(x, L, d, state.massKg);
}

// ════════════════════════════════════════════════════════════════════════
//  CANVAS REFERENCES
// ════════════════════════════════════════════════════════════════════════

const sceneCanvas = document.getElementById('sceneCanvas');
const sceneCtx    = sceneCanvas.getContext('2d');
const graphCanvas = document.getElementById('graphCanvas');
const graphCtx    = graphCanvas.getContext('2d');

// ════════════════════════════════════════════════════════════════════════
//  DRAW: SCENE
// ════════════════════════════════════════════════════════════════════════

const SC = {
  L: 55, R: 820, T: 20, B: 270,
};

function sceneX(physX) {
  return SC.L + (physX / state.spanM) * (SC.R - SC.L);
}

function sceneY(sag) {
  const maxD  = Math.max(state._dCenter * 2.5, 0.5);
  const frac  = sag / maxD;
  const ancY  = SC.T + 30;
  return ancY + frac * (SC.B - ancY - 20);
}

function drawArrow(ctx, x1, y1, x2, y2, color, lw, headLen) {
  const dx = x2 - x1, dy = y2 - y1;
  const angle = Math.atan2(dy, dx);
  ctx.strokeStyle = color;
  ctx.lineWidth   = lw;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  // head
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen * Math.cos(angle - 0.4), y2 - headLen * Math.sin(angle - 0.4));
  ctx.lineTo(x2 - headLen * Math.cos(angle + 0.4), y2 - headLen * Math.sin(angle + 0.4));
  ctx.closePath();
  ctx.fill();
}

function drawScene(f) {
  const ctx  = sceneCtx;
  const W    = sceneCanvas.width;
  const H    = sceneCanvas.height;

  ctx.clearRect(0, 0, W, H);

  // background
  ctx.fillStyle = '#061520';
  ctx.beginPath();
  ctx.roundRect(0, 0, W, H, 6);
  ctx.fill();

  const ancY   = sceneY(0);
  const loadPx = sceneX(f.x);
  const loadPy = sceneY(f.d);
  const anchLx = sceneX(0);
  const anchRx = sceneX(state.spanM);

  // ── Reference horizontal line ──────────────────────────────────────
  ctx.strokeStyle = C.grid;
  ctx.lineWidth   = 1;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(SC.L, ancY);
  ctx.lineTo(SC.R, ancY);
  ctx.stroke();
  ctx.setLineDash([]);

  // ── Unloaded rope profile (tint) ──────────────────────────────────
  if (state.profile) {
    ctx.strokeStyle = '#143045';
    ctx.lineWidth   = 1.5;
    ctx.beginPath();
    ctx.moveTo(anchLx, ancY);
    for (let i = 0; i < PROFILE_N; i++) {
      const ratio = (i + 0.5) / PROFILE_N;
      ctx.lineTo(sceneX(ratio * state.spanM), sceneY(state.profile.d[i]));
    }
    ctx.lineTo(anchRx, ancY);
    ctx.stroke();
  }

  // ── Loaded rope (two segments, colored by tension) ─────────────────
  ctx.lineWidth = 4;
  ctx.strokeStyle = tensionColor(f.TL);
  ctx.beginPath();
  ctx.moveTo(anchLx, ancY);
  ctx.lineTo(loadPx, loadPy);
  ctx.stroke();

  ctx.strokeStyle = tensionColor(f.TR);
  ctx.beginPath();
  ctx.moveTo(loadPx, loadPy);
  ctx.lineTo(anchRx, ancY);
  ctx.stroke();

  // ── Anchors ────────────────────────────────────────────────────────
  const SQ = 9;
  const anchorPairs = [
    [anchLx, ancY, 'Anclaje A'],
    [anchRx, ancY, 'Anclaje B'],
  ];
  for (const [ax, ay, lbl] of anchorPairs) {
    // Wall/ground rectangle
    ctx.fillStyle = '#143045';
    const wallW = 16, wallH = 60;
    const isLeft = (ax === anchLx);
    ctx.fillRect(isLeft ? ax - wallW : ax, ay - wallH / 2, wallW, wallH);

    ctx.fillStyle = C.anchor;
    ctx.fillRect(ax - SQ, ay - SQ, SQ * 2, SQ * 2);
    ctx.strokeStyle = C.text;
    ctx.lineWidth   = 2;
    ctx.strokeRect(ax - SQ, ay - SQ, SQ * 2, SQ * 2);

    ctx.fillStyle   = C.anchor;
    ctx.font        = 'bold 11px Segoe UI, sans-serif';
    ctx.textAlign   = 'center';
    ctx.fillText(lbl, ax, ay - 16);
  }

  // ── Tension arrows at anchors ──────────────────────────────────────
  const ARR_MAX = 80;
  const anchors = [[anchLx, ancY, f.TL], [anchRx, ancY, f.TR]];
  for (const [ax, ay, T] of anchors) {
    const ratio  = Math.min(T / ROPE_MBS, 1.0);
    const arrLen = 28 + ratio * (ARR_MAX - 28);
    const lw     = Math.max(2, 2 + ratio * 3);
    const vecX   = loadPx - ax;
    const vecY   = loadPy - ay;
    const norm   = Math.sqrt(vecX * vecX + vecY * vecY);
    if (norm < 1) continue;
    const ux = vecX / norm, uy = vecY / norm;
    const ex = ax + arrLen * ux, ey = ay + arrLen * uy;
    drawArrow(ctx, ax, ay, ex, ey, COL_ARR, lw, 10);

    // Label
    ctx.fillStyle  = COL_ARR;
    ctx.font       = '11px Segoe UI, sans-serif';
    ctx.textAlign  = (ax < loadPx) ? 'left' : 'right';
    ctx.fillText(`${T.toFixed(1)} kN`, ex + (ax < loadPx ? 6 : -6), ey);
  }

  // ── Angle V arc at load point ──────────────────────────────────────
  const vCol  = safetyColor(f.vAngle);
  const arcR  = 32;
  const aLrad = Math.atan2(-(ancY - loadPy), anchLx - loadPx);
  const aRrad = Math.atan2(-(ancY - loadPy), anchRx - loadPx);
  const startA = Math.min(aLrad, aRrad);
  const endA   = Math.max(aLrad, aRrad);

  ctx.strokeStyle = vCol;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  for (let i = 0; i <= 40; i++) {
    const a  = startA + (endA - startA) * i / 40;
    const px = loadPx + arcR * Math.cos(a);
    const py = loadPy - arcR * Math.sin(a);
    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();

  // V label
  const midA = (startA + endA) / 2;
  const lblX  = loadPx + (arcR + 16) * Math.cos(midA);
  const lblY  = loadPy - (arcR + 16) * Math.sin(midA);
  ctx.fillStyle  = vCol;
  ctx.font       = 'bold 12px Segoe UI, sans-serif';
  ctx.textAlign  = 'center';
  ctx.fillText(`${f.vAngle.toFixed(1)}°`, lblX, lblY + 4);

  // ── Vertical sag indicator ─────────────────────────────────────────
  const sagX = loadPx + 38;
  ctx.strokeStyle = C.warning;
  ctx.lineWidth   = 1;
  ctx.beginPath();
  ctx.moveTo(sagX, ancY);
  ctx.lineTo(sagX, loadPy);
  ctx.stroke();
  for (const yy of [ancY, loadPy]) {
    ctx.beginPath();
    ctx.moveTo(sagX - 5, yy);
    ctx.lineTo(sagX + 5, yy);
    ctx.stroke();
  }
  const midSagY = (ancY + loadPy) / 2;
  ctx.fillStyle  = C.warning;
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'left';
  ctx.fillText(`d=${f.d.toFixed(2)}m (${(f.d / state.spanM * 100).toFixed(1)}%)`, sagX + 7, midSagY + 4);

  // ── Litter (camilla) ───────────────────────────────────────────────
  drawLitter(ctx, loadPx, loadPy, f);

  // ── Angle labels near anchors ──────────────────────────────────────
  ctx.fillStyle  = C.text;
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'left';
  ctx.fillText(`αL=${f.alphaLDeg.toFixed(1)}°`, anchLx + 14, ancY + 5);
  ctx.textAlign  = 'right';
  ctx.fillText(`αR=${f.alphaRDeg.toFixed(1)}°`, anchRx - 14, ancY + 5);

  // ── Position label ─────────────────────────────────────────────────
  ctx.fillStyle  = C.text;
  ctx.font       = '11px Segoe UI, sans-serif';
  ctx.textAlign  = 'center';
  ctx.fillText(`x = ${f.x.toFixed(1)} m  (${(state.loadPos * 100).toFixed(0)}% del vano)`, loadPx, SC.B - 5);
}

function drawLitter(ctx, cx, cy, f) {
  // Rope-to-litter sling
  ctx.strokeStyle = C.anchor;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx, cy + 12);
  ctx.stroke();

  // Pulley
  ctx.strokeStyle = C.text;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, 6, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = C.anchor;
  ctx.beginPath();
  ctx.arc(cx, cy, 3, 0, Math.PI * 2);
  ctx.fill();

  // Litter body
  const lw = 54, lh = 22, ly = cy + 14;
  const vCol = safetyColor(f.vAngle);

  ctx.fillStyle = vCol;
  ctx.beginPath();
  ctx.roundRect(cx - lw / 2, ly, lw, lh, 4);
  ctx.fill();

  ctx.strokeStyle = C.text;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.roundRect(cx - lw / 2, ly, lw, lh, 4);
  ctx.stroke();

  // Person figure
  ctx.fillStyle = C.primary;
  ctx.beginPath();
  ctx.arc(cx - 10, ly + 8, 5, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = C.primary;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.moveTo(cx - 10, ly + 13);
  ctx.lineTo(cx - 10, ly + lh - 2);
  ctx.stroke();

  // Mass label
  ctx.fillStyle  = C.text;
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'left';
  ctx.fillText(`${state.massKg}kg`, cx + 4, ly + 14);

  // Weight arrow
  const arrowTop = ly + lh + 4;
  const arrowBot = arrowTop + 26;
  ctx.strokeStyle = C.danger;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.moveTo(cx, arrowTop);
  ctx.lineTo(cx, arrowBot);
  ctx.stroke();
  ctx.fillStyle = C.danger;
  ctx.beginPath();
  ctx.moveTo(cx, arrowBot + 5);
  ctx.lineTo(cx - 4, arrowBot);
  ctx.lineTo(cx + 4, arrowBot);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle  = C.danger;
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'left';
  ctx.fillText(`W=${f.W.toFixed(2)}kN`, cx + 7, arrowTop + 14);
}

// ════════════════════════════════════════════════════════════════════════
//  DRAW: GRAPHS
// ════════════════════════════════════════════════════════════════════════

const GC = {
  L: 52, R: 820, padR: 12
};

function drawGraphs(f) {
  const ctx = graphCtx;
  const GW  = graphCanvas.width;
  const GH  = graphCanvas.height;

  ctx.clearRect(0, 0, GW, GH);
  ctx.fillStyle = '#061520';
  ctx.beginPath();
  ctx.roundRect(0, 0, GW, GH, 6);
  ctx.fill();

  if (!state.profile) return;

  const gxL = GC.L;
  const gxR = GC.R;
  const gW  = gxR - gxL;

  // ── SUBPLOT SUPERIOR: TENSIÓN ──────────────────────────────────────
  const tTop = 16, tH = 85;

  // background
  ctx.fillStyle = '#0e0e1a';
  ctx.fillRect(gxL, tTop, gW, tH);

  // Y scale
  const allT  = [...state.profile.TL, ...state.profile.TR];
  const maxT  = Math.min(Math.max(...allT, NFPA * 1.1, 5.0), 80.0);

  function mapT(t) {
    return tTop + tH - (Math.min(t, maxT) / maxT) * tH;
  }

  function mapX(ratio) {
    return gxL + ratio * gW;
  }

  // Grid lines & labels
  for (const tv of [5, 10, NFPA, 20, 25, ROPE_MBS]) {
    if (tv > maxT) continue;
    const yy  = mapT(tv);
    const isL = (tv === NFPA || tv === ROPE_MBS);
    ctx.strokeStyle = isL ? C.danger : C.grid;
    ctx.lineWidth   = isL ? 1.5 : 1;
    ctx.setLineDash(isL ? [] : [3, 3]);
    ctx.beginPath();
    ctx.moveTo(gxL, yy);
    ctx.lineTo(gxR, yy);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle  = isL ? C.danger : C.grid;
    ctx.font       = '10px Segoe UI, sans-serif';
    ctx.textAlign  = 'right';
    let lbl = Number.isInteger(tv) ? `${tv}` : `${tv.toFixed(1)}`;
    if (tv === NFPA)     lbl += ' N';
    if (tv === ROPE_MBS) lbl += ' M';
    ctx.fillText(lbl, gxL - 3, yy + 4);
  }

  // kN label
  ctx.fillStyle  = C.grid;
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'right';
  ctx.fillText('kN', gxL - 3, tTop + 10);

  // Tension curves
  const curveData = [
    { arr: state.profile.TL, col: COL_TL },
    { arr: state.profile.TR, col: COL_TR },
  ];
  for (const { arr, col } of curveData) {
    ctx.strokeStyle = col;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    for (let i = 0; i < PROFILE_N; i++) {
      const px = mapX((i + 0.5) / PROFILE_N);
      const py = Math.max(tTop, Math.min(mapT(arr[i]), tTop + tH));
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.stroke();
  }

  // Current position line
  const curX = mapX(state.loadPos);
  ctx.strokeStyle = C.warning;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.moveTo(curX, tTop);
  ctx.lineTo(curX, tTop + tH);
  ctx.stroke();

  // Current dots
  for (const [T, col] of [[f.TL, COL_TL], [f.TR, COL_TR]]) {
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(curX, Math.max(tTop + 3, Math.min(mapT(T), tTop + tH - 3)), 5, 0, Math.PI * 2);
    ctx.fill();
  }

  // Legend
  let lx = gxL + 8;
  ctx.font = '10px Segoe UI, sans-serif';
  for (const [col, lbl] of [[COL_TL, 'T izq'], [COL_TR, 'T der']]) {
    ctx.strokeStyle = col;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.moveTo(lx, tTop + 8);
    ctx.lineTo(lx + 16, tTop + 8);
    ctx.stroke();
    ctx.fillStyle  = col;
    ctx.textAlign  = 'left';
    ctx.fillText(lbl, lx + 20, tTop + 12);
    lx += 70;
  }
  // NFPA/MBS legend
  ctx.fillStyle = C.danger;
  ctx.fillText(`NFPA = ${NFPA} kN (N)  MBS = ${ROPE_MBS} kN (M)`, lx + 10, tTop + 12);

  // Subplot title
  ctx.fillStyle  = '#78909C';
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'right';
  ctx.fillText('Tensiones vs Posición', gxR, tTop - 2);

  // ── SUBPLOT INFERIOR: ÁNGULOS ──────────────────────────────────────
  const aTop = tTop + tH + 20, aH = 80;

  // Subplot title
  ctx.fillStyle  = '#78909C';
  ctx.font       = '10px Segoe UI, sans-serif';
  ctx.textAlign  = 'right';
  ctx.fillText('Ángulos vs Posición  [αL/αR: 0–90° | V: 0–180°]', gxR, aTop - 2);

  // Background with danger zones for V angle
  const vZones = [
    [0,   120, 'rgba(15,50,15,0.7)'],
    [120, 140, 'rgba(50,45,8,0.7)'],
    [140, 160, 'rgba(55,28,8,0.7)'],
    [160, 180, 'rgba(60,10,10,0.7)'],
  ];

  function mapA(deg, maxDeg) {
    const frac = Math.max(0, Math.min(deg / maxDeg, 1));
    return aTop + aH - frac * aH;
  }

  // Fill zone backgrounds
  for (const [vLo, vHi, zoneFill] of vZones) {
    const yTop = Math.max(aTop, mapA(vHi, 180));
    const yBot = Math.min(aTop + aH, mapA(vLo, 180));
    if (yBot > yTop) {
      ctx.fillStyle = zoneFill;
      ctx.fillRect(gxL, yTop, gW, yBot - yTop);
    }
  }

  // V reference lines
  const vRefs = [[120, C.accent], [140, C.secondary], [160, C.danger]];
  for (const [vDeg, vCol] of vRefs) {
    const yy = mapA(vDeg, 180);
    if (yy >= aTop && yy <= aTop + aH) {
      ctx.strokeStyle = vCol;
      ctx.lineWidth   = 1;
      ctx.setLineDash([4, 3]);
      ctx.beginPath();
      ctx.moveTo(gxL, yy);
      ctx.lineTo(gxR, yy);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle  = vCol;
      ctx.font       = '10px Segoe UI, sans-serif';
      ctx.textAlign  = 'left';
      ctx.fillText(`V=${vDeg}°`, gxR + 3, yy + 4);
    }
  }

  // Alpha grid (0-90°)
  for (const deg of [30, 60, 90]) {
    const yy = mapA(deg, 90);
    if (yy >= aTop && yy <= aTop + aH) {
      ctx.strokeStyle = C.grid;
      ctx.lineWidth   = 1;
      ctx.setLineDash([2, 4]);
      ctx.beginPath();
      ctx.moveTo(gxL, yy);
      ctx.lineTo(gxR, yy);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle  = C.grid;
      ctx.font       = '10px Segoe UI, sans-serif';
      ctx.textAlign  = 'right';
      ctx.fillText(`${deg}`, gxL - 3, yy + 4);
    }
  }

  // Curves alphaL, alphaR (0-90 scale)
  for (const [arr, col] of [[state.profile.AL, COL_AL], [state.profile.AR, COL_AR]]) {
    ctx.strokeStyle = col;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    for (let i = 0; i < PROFILE_N; i++) {
      const px = mapX((i + 0.5) / PROFILE_N);
      const py = Math.max(aTop, Math.min(mapA(arr[i], 90), aTop + aH));
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.stroke();
  }

  // V curve (0-180 scale, dashed)
  ctx.strokeStyle = COL_V;
  ctx.lineWidth   = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  for (let i = 0; i < PROFILE_N; i++) {
    const px = mapX((i + 0.5) / PROFILE_N);
    const py = Math.max(aTop, Math.min(mapA(state.profile.V[i], 180), aTop + aH));
    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Current position line (angle subplot)
  ctx.strokeStyle = C.warning;
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.moveTo(curX, aTop);
  ctx.lineTo(curX, aTop + aH);
  ctx.stroke();

  // Current dots on angle plot
  const alPy = Math.max(aTop + 2, Math.min(mapA(f.alphaLDeg, 90), aTop + aH - 2));
  const arPy = Math.max(aTop + 2, Math.min(mapA(f.alphaRDeg, 90), aTop + aH - 2));
  const vPy  = Math.max(aTop + 2, Math.min(mapA(f.vAngle, 180), aTop + aH - 2));

  for (const [py, col] of [[alPy, COL_AL], [arPy, COL_AR], [vPy, COL_V]]) {
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(curX, py, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  // Value labels next to dots
  const lblOff = (curX + 50 < gxR) ? 7 : -52;
  ctx.font = '10px Segoe UI, sans-serif';
  ctx.textAlign = lblOff > 0 ? 'left' : 'right';

  ctx.fillStyle = COL_AL;
  ctx.fillText(`αL=${f.alphaLDeg.toFixed(0)}°`, curX + lblOff, alPy - 6);
  ctx.fillStyle = COL_AR;
  ctx.fillText(`αR=${f.alphaRDeg.toFixed(0)}°`, curX + lblOff, arPy + 12);
  ctx.fillStyle = COL_V;
  ctx.fillText(`V=${f.vAngle.toFixed(0)}°`, curX + lblOff, vPy - 14);

  // X axis ticks
  for (const pct of [0, 0.25, 0.5, 0.75, 1.0]) {
    const xx = mapX(pct);
    ctx.strokeStyle = C.grid;
    ctx.lineWidth   = 1;
    ctx.beginPath();
    ctx.moveTo(xx, aTop);
    ctx.lineTo(xx, aTop + aH);
    ctx.stroke();
    ctx.fillStyle  = C.grid;
    ctx.font       = '10px Segoe UI, sans-serif';
    ctx.textAlign  = 'center';
    ctx.fillText(`${Math.round(pct * 100)}%`, xx, aTop + aH + 12);
  }

  // Legend angles
  lx = gxL + 8;
  ctx.font = '10px Segoe UI, sans-serif';
  for (const [col, lbl, dashed] of [
    [COL_AL, 'αL: ángulo izq (0–90°)', false],
    [COL_AR, 'αR: ángulo der (0–90°)', false],
    [COL_V,  'V: apertura en carga (0–180°, - -)', true],
  ]) {
    if (dashed) ctx.setLineDash([5, 3]);
    ctx.strokeStyle = col;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.moveTo(lx, aTop + 9);
    ctx.lineTo(lx + 16, aTop + 9);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle  = col;
    ctx.textAlign  = 'left';
    ctx.fillText(lbl, lx + 20, aTop + 13);
    lx += ctx.measureText(lbl).width + 40;
  }
}

// ════════════════════════════════════════════════════════════════════════
//  UPDATE RIGHT PANEL (HTML elements)
// ════════════════════════════════════════════════════════════════════════

function updatePanel(f) {
  const L = state.spanM;

  // Parámetros
  document.getElementById('pSpan').textContent  = `${L.toFixed(0)} m`;
  document.getElementById('pSag').textContent   = `${state._dCenter.toFixed(2)} m (${state.sagPct.toFixed(1)}%)`;
  document.getElementById('pMass').textContent  = `${state.massKg} kg (${f.W.toFixed(2)} kN)`;
  document.getElementById('pPos').textContent   = `${f.x.toFixed(1)} m (${(state.loadPos * 100).toFixed(0)}%)`;

  // Ángulos
  document.getElementById('pAlphaL').textContent = `${f.alphaLDeg.toFixed(1)}°`;
  document.getElementById('pAlphaR').textContent = `${f.alphaRDeg.toFixed(1)}°`;
  const vEl    = document.getElementById('pVangle');
  const vColor = safetyColor(f.vAngle);
  vEl.textContent = `${f.vAngle.toFixed(1)}°`;
  vEl.style.color = vColor;

  const vStat  = document.getElementById('vStatus');
  if (f.vAngle > 160) {
    vStat.textContent = 'CRÍTICO: ángulo muy abierto — fuerzas extremas';
    vStat.style.background = '#3a0808';
    vStat.style.color = C.danger;
  } else if (f.vAngle > 140) {
    vStat.textContent = 'PELIGROSO: fuerzas muy altas';
    vStat.style.background = '#2e1505';
    vStat.style.color = C.secondary;
  } else if (f.vAngle > 120) {
    vStat.textContent = 'PRECAUCIÓN: monitorear tensión';
    vStat.style.background = '#2e2300';
    vStat.style.color = C.warning;
  } else {
    vStat.textContent = 'Ángulo aceptable';
    vStat.style.background = '#0e2a10';
    vStat.style.color = C.accent;
  }

  // Tensiones
  document.getElementById('pH').textContent  = `${f.H.toFixed(2)} kN`;
  document.getElementById('pTL').textContent = `${f.TL.toFixed(2)} kN`;
  document.getElementById('pTR').textContent = `${f.TR.toFixed(2)} kN`;

  const barMax = ROPE_MBS * 1.1;

  function setBar(fillId, T) {
    const el  = document.getElementById(fillId);
    const pct = Math.min(T / barMax * 100, 100);
    el.style.width      = `${pct}%`;
    el.style.background = tensionColor(T);
  }

  setBar('barTL', f.TL);
  setBar('barTR', f.TR);

  // NFPA / MBS marker positions
  const nfpaPct = NFPA / barMax * 100;
  const mbsPct  = ROPE_MBS / barMax * 100;

  for (const [nId, mId] of [['markNFPA_L', 'markMBS_L'], ['markNFPA_R', 'markMBS_R']]) {
    document.getElementById(nId).style.left = `${nfpaPct}%`;
    document.getElementById(mId).style.left = `${mbsPct}%`;
  }

  // Seguridad
  const Tmax  = Math.max(f.TL, f.TR);
  const nStat = document.getElementById('nfpaStatus');
  if (Tmax <= NFPA) {
    nStat.textContent = `NFPA: ${Tmax.toFixed(1)} ≤ ${NFPA} kN [OK]`;
    nStat.style.background = '#0e2a10'; nStat.style.color = C.accent;
  } else {
    nStat.textContent = `NFPA: ${Tmax.toFixed(1)} > ${NFPA} kN [EXCEDE]`;
    nStat.style.background = '#3a0808'; nStat.style.color = C.danger;
  }

  const sf     = Tmax > 0 ? ROPE_MBS / Tmax : 999;
  const fsStat = document.getElementById('fsStatus');
  if (sf >= 10) {
    fsStat.textContent = `FS rotura: ${sf.toFixed(1)}:1 [OK]`;
    fsStat.style.background = '#0e2a10'; fsStat.style.color = C.accent;
  } else if (sf >= 3) {
    fsStat.textContent = `FS rotura: ${sf.toFixed(1)}:1 [BAJO]`;
    fsStat.style.background = '#2e2300'; fsStat.style.color = C.warning;
  } else {
    fsStat.textContent = `FS rotura: ${sf.toFixed(1)}:1 [CRÍTICO]`;
    fsStat.style.background = '#3a0808'; fsStat.style.color = C.danger;
  }

  const vagStat = document.getElementById('vagStatus');
  if (f.vAngle < 120) {
    vagStat.textContent = `Ángulo V: ${f.vAngle.toFixed(0)}° [OK]`;
    vagStat.style.background = '#0e2a10'; vagStat.style.color = C.accent;
  } else if (f.vAngle < 160) {
    vagStat.textContent = `Ángulo V: ${f.vAngle.toFixed(0)}° [AMPLIO]`;
    vagStat.style.background = '#2e2300'; vagStat.style.color = C.warning;
  } else {
    vagStat.textContent = `Ángulo V: ${f.vAngle.toFixed(0)}° [CRÍTICO]`;
    vagStat.style.background = '#3a0808'; vagStat.style.color = C.danger;
  }

  const dMin    = f.W * L / (4 * NFPA);
  const sagMinP = dMin / L * 100;
  document.getElementById('pSagMin').textContent = `${sagMinP.toFixed(1)}% (${dMin.toFixed(2)} m)`;
}

// ════════════════════════════════════════════════════════════════════════
//  ANIMATION LOOP
// ════════════════════════════════════════════════════════════════════════

let lastTime = null;

function loop(ts) {
  if (lastTime === null) lastTime = ts;
  const dt = Math.min((ts - lastTime) / 1000.0, 0.1);
  lastTime = ts;

  if (state.autoTraverse) {
    state.loadPos += state.traverseDir * TRAVERSE_SPD * dt;
    if (state.loadPos >= 0.95) { state.loadPos = 0.95; state.traverseDir = -1; }
    if (state.loadPos <= 0.05) { state.loadPos = 0.05; state.traverseDir =  1; }
    // sync slider
    document.getElementById('slPos').value  = (state.loadPos * 100).toFixed(1);
    document.getElementById('valPos').textContent = `${(state.loadPos * 100).toFixed(1)} %`;
  }

  const f = currentForces();
  drawScene(f);
  drawGraphs(f);
  updatePanel(f);

  requestAnimationFrame(loop);
}

// ════════════════════════════════════════════════════════════════════════
//  CONTROLS WIRING
// ════════════════════════════════════════════════════════════════════════

function resetState() {
  state.spanM       = 30;
  state.sagPct      = 5;
  state.massKg      = 100;
  state.loadPos     = 0.5;
  state.autoTraverse = false;
  state.traverseDir = 1;

  document.getElementById('slSpan').value = 30;
  document.getElementById('slSag').value  = 5;
  document.getElementById('slMass').value = 100;
  document.getElementById('slPos').value  = 50;

  document.getElementById('valSpan').textContent = '30 m';
  document.getElementById('valSag').textContent  = '5.0 %';
  document.getElementById('valMass').textContent = '100 kg';
  document.getElementById('valPos').textContent  = '50 %';

  document.getElementById('btnAuto').classList.remove('active');
  document.getElementById('btnAuto').textContent = '▶ Auto-travesía';

  rebuildProfile();
}

document.getElementById('slSpan').addEventListener('input', function () {
  state.spanM = parseFloat(this.value);
  document.getElementById('valSpan').textContent = `${state.spanM.toFixed(0)} m`;
  rebuildProfile();
});

document.getElementById('slSag').addEventListener('input', function () {
  state.sagPct = parseFloat(this.value);
  document.getElementById('valSag').textContent = `${state.sagPct.toFixed(1)} %`;
  rebuildProfile();
});

document.getElementById('slMass').addEventListener('input', function () {
  state.massKg = parseInt(this.value, 10);
  document.getElementById('valMass').textContent = `${state.massKg} kg`;
  rebuildProfile();
});

document.getElementById('slPos').addEventListener('input', function () {
  state.loadPos = parseFloat(this.value) / 100;
  document.getElementById('valPos').textContent = `${parseFloat(this.value).toFixed(1)} %`;
});

document.getElementById('btnAuto').addEventListener('click', function () {
  state.autoTraverse = !state.autoTraverse;
  if (state.autoTraverse) {
    this.classList.add('active');
    this.textContent = '⏸ Detener travesía';
  } else {
    this.classList.remove('active');
    this.textContent = '▶ Auto-travesía';
  }
});

document.getElementById('btnReset').addEventListener('click', resetState);

// ════════════════════════════════════════════════════════════════════════
//  INIT
// ════════════════════════════════════════════════════════════════════════

rebuildProfile();
requestAnimationFrame(loop);

</script>

          </div><!-- /.sim-content -->
        </div>
      </div><!-- /.cover -->
    </div><!-- /.container -->
  </div><!-- /.page-content -->

  <footer class="site-footer d-print-none">
    <div class="container text-center">
      <p>&copy; <span id="footer-year"></span> Jorge A. Balsells Orellana. All rights reserved.</p>
    </div>
  </footer>

  <button class="back-to-top d-print-none" id="backToTop" aria-label="Back to top">
    <i class="fas fa-chevron-up"></i>
  </button>

  <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="../scripts/aos.js"></script>
  <script src="../scripts/main.js"></script>

</body>
</html>
