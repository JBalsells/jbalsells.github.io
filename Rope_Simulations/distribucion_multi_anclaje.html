<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Física del Rescate — Distribución Multi-Anclaje</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&family=Roboto:wght@300;400;500;700&display=swap">
  <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="../css/font-awesome/css/all.min.css" rel="stylesheet">
  <link href="../css/main.css" rel="stylesheet">
  <style>
    .sim-content *, .sim-content *::before, .sim-content *::after { box-sizing: border-box; margin: 0; padding: 0; }


    h1 {
      font-size: 1.4rem;
      color: #00BCD4;
      text-align: center;
      margin-bottom: 3px;
      letter-spacing: 0.4px;
    }

    .subtitle {
      font-size: 0.82rem;
      color: #78909C;
      text-align: center;
      margin-bottom: 10px;
    }

    .main-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      margin-bottom: 10px;
      min-width: max-content;
    }

    canvas {
      display: block;
      border-radius: 8px;
      border: 1px solid #143045;
      background: #061520;
      flex-shrink: 0;
    }

    /* ── Side panel ───────────────────────────────────────────── */
    .side-panel {
      flex: 1;
      min-width: 340px;
      max-width: 410px;
      background: #0a1e2f;
      border: 1px solid #00BCD4;
      border-radius: 8px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 0.82rem;
    }

    .panel-section-title {
      font-size: 0.78rem;
      font-weight: bold;
      color: #00BCD4;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      margin-bottom: 4px;
      border-bottom: 1px solid #143045;
      padding-bottom: 3px;
    }

    .param-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 10px;
      font-size: 0.81rem;
    }

    .param-label { color: #78909C; }
    .param-value { color: #ECEFF1; font-weight: bold; font-variant-numeric: tabular-nums; }

    /* Anchor table */
    .anchor-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.79rem;
    }
    .anchor-table th {
      color: #78909C;
      font-weight: normal;
      text-align: left;
      padding: 2px 4px;
      border-bottom: 1px solid #143045;
    }
    .anchor-table td {
      padding: 3px 4px;
      font-variant-numeric: tabular-nums;
      border-bottom: 1px solid #1a2040;
    }

    .status-ok      { color: #4CAF50; }
    .status-caution { color: #FFC107; }
    .status-danger  { color: #F44336; }

    /* Bar chart */
    .bar-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .bar-label { width: 24px; font-size: 0.75rem; font-weight: bold; }
    .bar-track {
      flex: 1;
      height: 14px;
      background: #252540;
      border-radius: 3px;
      position: relative;
      overflow: visible;
    }
    .bar-fill {
      height: 100%;
      border-radius: 3px;
      transition: width 0.1s;
    }
    .bar-ideal-line {
      position: absolute;
      top: -2px;
      bottom: -2px;
      width: 2px;
      background: rgba(255,255,255,0.5);
    }
    .bar-pct { width: 68px; font-size: 0.75rem; font-variant-numeric: tabular-nums; }

    /* Failure analysis */
    .fail-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.79rem;
      padding: 2px 0;
    }

    /* Educational notes */
    .edu-line { color: #78909C; font-size: 0.77rem; margin-bottom: 2px; }
    .edu-formula { color: #2196F3; font-style: italic; font-size: 0.77rem; margin-bottom: 4px; }
    .edu-accent  { color: #4CAF50; }
    .edu-warning { color: #FFC107; }
    .edu-danger  { color: #F44336; }

    /* Status badge */
    #statusBadge {
      text-align: center;
      font-weight: bold;
      font-size: 0.83rem;
      padding: 5px 10px;
      border-radius: 5px;
      border: 2px solid #4CAF50;
      color: #4CAF50;
      background: rgba(76,175,80,0.08);
      transition: all 0.15s;
    }

    /* Controls bar */
    .controls-bar {
      width: 100%;
      max-width: 1290px;
      background: #0a1e2f;
      border: 1px solid #143045;
      border-radius: 8px;
      padding: 9px 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      align-items: center;
      justify-content: center;
      font-size: 0.78rem;
      color: #78909C;
    }

    .ctrl-btn {
      background: #1e2a4a;
      border: 1px solid #2a3a5a;
      border-radius: 5px;
      color: #ECEFF1;
      font-size: 0.78rem;
      padding: 4px 10px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .ctrl-btn:hover { background: #243060; border-color: #00BCD4; }
    .ctrl-btn.active { background: #F44336; border-color: #F44336; color: #fff; }
    .ctrl-btn.selected-3 { border-color: #00BCD4; }
    .ctrl-btn.selected-4 { border-color: #00BCD4; }

    kbd {
      display: inline-block;
      background: #252540;
      border: 1px solid #3a3a60;
      border-radius: 3px;
      padding: 1px 5px;
      font-size: 0.75rem;
      color: #ECEFF1;
      font-family: monospace;
    }

    .footer {
      margin-top: 10px;
      font-size: 0.72rem;
      color: #ECEFF1;
      opacity: 0.45;
      font-style: italic;
      text-align: center;
      max-width: 1290px;
      line-height: 1.6;
    }

  
    /* ─── Simulation content panel ───────────────────────────────────── */
    /* Override main.css .cover { overflow: hidden } so the canvas can scroll */
    .cover { overflow-x: auto; }

    .sim-content {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      padding: 20px 8px 24px;
      background: #061520;
      border-radius: 8px;
      color: #ECEFF1;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    }

    /* ─── Back button ─────────────────────────────────────────────────── */
    .btn-back {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.42rem 1.1rem;
      margin-bottom: 1.2rem;
      border-radius: 999px;
      font-size: 0.82rem;
      font-weight: 500;
      letter-spacing: 0.03em;
      color: var(--color-primary);
      background: var(--color-primary-light);
      border: 1.5px solid var(--color-primary-medium);
      text-decoration: none;
      transition: background 0.18s, color 0.18s, transform 0.15s,
                  box-shadow 0.18s, border-color 0.18s;
    }
    .btn-back:hover {
      background: var(--color-primary);
      color: #fff;
      border-color: var(--color-primary);
      transform: translateX(-3px);
      box-shadow: 0 4px 16px rgba(26, 79, 100, 0.25);
      text-decoration: none;
    }
    .btn-back-arrow {
      font-size: 0.72rem;
      transition: transform 0.18s;
    }
    .btn-back:hover .btn-back-arrow {
      transform: translateX(-3px);
    }

    /* ── Responsive scaling ─────────────────────────────────── */
    @media (max-width: 700px) {
      .slider-row { grid-template-columns: 1fr auto !important; }
      .slider-row .slider-label,
      .slider-row label { grid-column: 1 / -1; text-align: left !important; }
    }
  </style>
  <script>(function(){var t=localStorage.getItem('theme');if(t)document.documentElement.setAttribute('data-theme',t);})();</script>
</head>
<body id="top">
  <!-- Scroll progress bar -->
  <div class="scroll-progress d-print-none" id="scrollProgress"></div>

  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark sticky-nav d-print-none">
    <div class="container">
      <a class="navbar-brand" href="../index.html">Jorge A. Balsells Orellana</a>
      <div class="d-flex align-items-center ms-auto d-lg-none">
        <button class="btn btn-link nav-dark-toggle me-2" id="darkToggleMobile" aria-label="Toggle dark mode">
          <i class="fas fa-moon"></i>
        </button>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarMain" aria-controls="navbarMain" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
      </div>
      <div class="collapse navbar-collapse" id="navbarMain">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item"><a class="nav-link" href="../index.html#about">About</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#skills">Skills</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#experience">Experience</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#education">Education</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#certs">Courses</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#projects">Projects</a></li>
          <li class="nav-item"><a class="nav-link" href="../index.html#volunteer">Volunteering</a></li>
          <li class="nav-item"><a class="nav-link" href="../gallery.html">Gallery</a></li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle active" href="#" id="othersDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Others
            </a>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="othersDropdown">
              <li><a class="dropdown-item" href="../rope_simulations.html">Rope Simulations</a></li>
            </ul>
          </li>
          <li class="nav-item nav-contact-pill"><a class="nav-link" href="../index.html#contact"><i class="fas fa-envelope me-1"></i>Contact</a></li>
          <li class="nav-item d-none d-lg-block">
            <button class="btn btn-link nav-dark-toggle" id="darkToggleDesktop" aria-label="Toggle dark mode">
              <i class="fas fa-moon"></i>
            </button>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="page-content">
    <div class="container">
      <div class="cover shadow-sm">
        <div class="px-3 px-lg-4 py-4">
          <a href="../rope_simulations.html" class="btn-back"><i class="fas fa-chevron-left btn-back-arrow"></i> Rope Simulations</a>
          <h2 class="section-heading"><i class="fas fa-project-diagram"></i>Distribución Multi-Anclaje</h2>
          <div class="sim-content">



<h1>DISTRIBUCIÓN DE FUERZAS EN MULTI-ANCLAJE</h1>
<p class="subtitle">Sistema auto-ecualizado — Arrastre los anclajes o use las flechas del teclado</p>

<div class="main-row" id="mainRow">
  <canvas id="simCanvas" width="850" height="730"></canvas>

  <!-- ── Side panel ──────────────────────────────────────────── -->
  <div class="side-panel" id="sidePanel">

    <!-- Parámetros -->
    <div>
      <div class="panel-section-title">Parámetros del sistema</div>
      <div class="param-grid">
        <span class="param-label">Masa:</span>
        <span class="param-value" id="pMasa">100 kg</span>
        <span class="param-label">Peso total (W):</span>
        <span class="param-value" id="pPeso">0.98 kN</span>
        <span class="param-label">Nº anclajes:</span>
        <span class="param-value" id="pNAnclajes">3</span>
        <span class="param-label">Seleccionado:</span>
        <span class="param-value" id="pSeleccionado">A1</span>
        <span class="param-label">Distribución ideal:</span>
        <span class="param-value" id="pIdeal">33.3% c/u</span>
      </div>
    </div>

    <!-- Tabla por anclaje -->
    <div>
      <div class="panel-section-title">Fuerza por anclaje</div>
      <table class="anchor-table">
        <thead>
          <tr>
            <th>Anclaje</th>
            <th>α (°)</th>
            <th>F (kN)</th>
            <th>%</th>
            <th>T tirante</th>
            <th>Estado</th>
          </tr>
        </thead>
        <tbody id="anchorTableBody">
          <!-- filled by JS -->
        </tbody>
      </table>
    </div>

    <!-- Gráfico de barras -->
    <div>
      <div class="panel-section-title">Distribución (%)</div>
      <div id="barChart">
        <!-- filled by JS -->
      </div>
    </div>

    <!-- Análisis de fallo -->
    <div>
      <div class="panel-section-title" id="failTitle">Si A1 falla:</div>
      <div id="failureAnalysis">
        <!-- filled by JS -->
      </div>
    </div>

    <!-- Estado global -->
    <div id="statusBadge">DISTRIBUCIÓN EQUILIBRADA</div>

    <!-- Notas educativas -->
    <div>
      <div class="panel-section-title">Fórmulas y conceptos</div>
      <div class="edu-formula">F_i = W × cos(α_i) / Σcos(α_j)</div>
      <div class="edu-line">α_i = ángulo del tirante i respecto a la vertical</div>
      <div class="edu-line" style="margin-top:4px;"><span class="edu-accent">▲</span> Tirante más vertical → más carga</div>
      <div class="edu-line"><span class="edu-warning">▲</span> Tirante más inclinado → menos carga</div>
      <div class="edu-line" style="margin-top:4px;"><span class="edu-danger">!</span> Si un anclaje falla: carga se redistribuye instantáneamente</div>
      <div class="edu-line"><span class="edu-danger">!</span> Genera carga de choque por extensión (×1.5 estimado)</div>
      <div class="edu-line"><span class="edu-danger">!</span> Los ángulos cambian → nueva distribución</div>
    </div>

  </div><!-- /side-panel -->
</div><!-- /main-row -->

<!-- ── Controls bar ───────────────────────────────────────── -->
<div class="controls-bar">
  <button class="ctrl-btn" id="btn3" onclick="sim.setNumAnchors(3)" title="3 anclajes [tecla 3]">3 anclajes</button>
  <button class="ctrl-btn" id="btn4" onclick="sim.setNumAnchors(4)" title="4 anclajes [tecla 4]">4 anclajes</button>
  <button class="ctrl-btn" onclick="sim.cycleSelected()" title="Ciclar anclaje seleccionado [Tab]"><kbd>Tab</kbd> Seleccionar</button>
  <button class="ctrl-btn" id="btnFallo" onclick="sim.toggleFailure()" title="Simular fallo [F]"><kbd>F</kbd> Simular fallo</button>
  <button class="ctrl-btn" onclick="sim.changeMass(+10)" title="Aumentar masa [W]"><kbd>W</kbd> +10 kg</button>
  <button class="ctrl-btn" onclick="sim.changeMass(-10)" title="Reducir masa [S]"><kbd>S</kbd> −10 kg</button>
  <button class="ctrl-btn" onclick="sim.reset()" title="Reiniciar [R]"><kbd>R</kbd> Reset</button>
  <span style="color:#546E7A;font-size:0.76rem;"><kbd>↑↓←→</kbd> Mover anclaje &nbsp;│&nbsp; <kbd>Mouse</kbd> Arrastrar</span>
</div>

<p class="footer">
  Física del Rescate · Módulo 14: Distribución Multi-Anclaje &nbsp;│&nbsp;
  ROPE_MBS = 30.0 kN &nbsp;│&nbsp; NFPA Work Load = 13.5 kN &nbsp;│&nbsp; ANCHOR_MBS = 25.0 kN
</p>

<script>
// ══════════════════════════════════════════════════════════════════════
//  Constantes físicas y de seguridad
// ══════════════════════════════════════════════════════════════════════
const G            = 9.81;
const ROPE_MBS     = 30.0;
const ANCHOR_MBS   = 25.0;
const NFPA         = 13.5;
const SHOCK_FACTOR = 1.5;

// ── Paleta de colores (de config.py) ─────────────────────────────────
const C = {
  bg:        '#061520',
  panel:     '#0a1e2f',
  primary:   '#00BCD4',
  secondary: '#FF5722',
  accent:    '#4CAF50',
  warning:   '#FFC107',
  danger:    '#F44336',
  info:      '#2196F3',
  text:      '#ECEFF1',
  grid:      '#143045',
  rope:      '#8D6E63',
  anchor:    '#78909C',
  dark_text: '#546E7A',
  white:     '#FFFFFF',
};

// ── Colores por anclaje ──────────────────────────────────────────────
const ANCHOR_COLORS = [
  '#00C8FF',  // A1 – cian
  '#FFB400',  // A2 – naranja
  '#B400FF',  // A3 – violeta
  '#00FF78',  // A4 – verde
];
const ANCHOR_LABELS = ['A1', 'A2', 'A3', 'A4'];

// ══════════════════════════════════════════════════════════════════════
//  Física: distribución de fuerzas en multi-anclaje auto-ecualizado
// ══════════════════════════════════════════════════════════════════════

function computeAnchorForces(anchorPositions, masterPoint, weightKN) {
  const [mx, my] = masterPoint;
  const n = anchorPositions.length;
  if (n === 0) return [];

  const results = [];
  let cosSum = 0.0;

  // Primera pasada: ángulos y cosenos
  for (let i = 0; i < n; i++) {
    const [ax, ay] = anchorPositions[i];
    const dx = ax - mx;
    const dy = my - ay;          // positivo hacia arriba
    let L = Math.sqrt(dx*dx + dy*dy);
    if (L < 1) L = 1;

    let cosAlpha = dy / L;
    cosAlpha = Math.max(cosAlpha, 0.01);
    const alphaDeg = Math.degrees(Math.acos(Math.min(cosAlpha, 1.0)));

    results.push({ index: i, pos: [...anchorPositions[i]], dx, dy,
                   L, alphaDeg, cosAlpha,
                   forceKN: 0, pct: 0, failed: false });
    cosSum += cosAlpha;
  }

  // Segunda pasada: fuerzas
  if (cosSum > 0.001) {
    results.forEach(r => {
      r.forceKN  = weightKN * r.cosAlpha / cosSum;
      r.pct      = r.forceKN / weightKN * 100.0;
    });
  } else {
    results.forEach(r => {
      r.forceKN  = weightKN / n;
      r.pct      = 100.0 / n;
    });
  }
  return results;
}

// Polyfill Math.degrees
Math.degrees = r => r * 180 / Math.PI;

function slingTension(forceKN, alphaDeg) {
  const cosA = Math.cos(alphaDeg * Math.PI / 180);
  if (cosA < 0.01) return 99.99;
  return forceKN / cosA;
}

function computeFailureScenario(anchorPositions, masterPoint, weightKN, failedIdx) {
  const remaining = anchorPositions.filter((_, i) => i !== failedIdx);
  const remainingIndices = anchorPositions.map((_, i) => i).filter(i => i !== failedIdx);

  if (remaining.length === 0) return [];

  const subResults = computeAnchorForces(remaining, masterPoint, weightKN);

  const full = [];
  let si = 0;
  for (let i = 0; i < anchorPositions.length; i++) {
    if (i === failedIdx) {
      full.push({ index: i, pos: [...anchorPositions[i]],
                  dx:0, dy:0, L:0, alphaDeg:0, cosAlpha:0,
                  forceKN:0, pct:0, failed:true });
    } else {
      const r = { ...subResults[si] };
      r.index = i;
      r.pos   = [...anchorPositions[i]];
      r.failed = false;
      full.push(r);
      si++;
    }
  }
  return full;
}

// ══════════════════════════════════════════════════════════════════════
//  Simulador principal
// ══════════════════════════════════════════════════════════════════════

class MultiAnchorSim {
  constructor(canvasId) {
    this.canvas  = document.getElementById(canvasId);
    this.ctx     = this.canvas.getContext('2d');
    this.W       = this.canvas.width;
    this.H       = this.canvas.height;

    // Scene bounds (relative to canvas)
    this.SCENE_LEFT   = 20;
    this.SCENE_RIGHT  = this.W - 20;
    this.SCENE_TOP    = 70;
    this.SCENE_BOTTOM = this.H - 30;

    // Master point (centro-inferior de la escena de anclajes)
    this.MPX = Math.round(this.W / 2);
    this.MPY = 520;

    this.massKg         = 100;
    this.numAnchors     = 3;
    this.selectedAnchor = 0;
    this.showFailure    = false;
    this.failedIdx      = -1;
    this.failFlash      = 0;

    this.anchorPositions = [];
    this.anchorResults   = [];
    this.failureResults  = [];

    this.draggingAnchor = -1;
    this.dragOffX = 0;
    this.dragOffY = 0;

    // Pressed keys for continuous movement
    this.keysDown = {};

    this._setupPositions();
    this._bindEvents();
    this._loop();
  }

  // ── Posiciones iniciales ──────────────────────────────────────────

  _setupPositions() {
    const cx     = this.MPX;
    const baseY  = 160;
    const spread = 200;

    if (this.numAnchors === 3) {
      this.anchorPositions = [
        [cx - spread, baseY],
        [cx,          baseY - 50],
        [cx + spread, baseY],
      ];
    } else {
      const s3 = Math.round(spread / 3);
      this.anchorPositions = [
        [cx - spread, baseY],
        [cx - s3,     baseY - 35],
        [cx + s3,     baseY - 35],
        [cx + spread, baseY],
      ];
    }

    this.showFailure = false;
    this.failedIdx   = -1;
    if (this.selectedAnchor >= this.numAnchors) this.selectedAnchor = 0;
  }

  reset() {
    this.massKg         = 100;
    this.selectedAnchor = 0;
    this._setupPositions();
  }

  setNumAnchors(n) {
    if (this.numAnchors === n) return;
    this.numAnchors = n;
    this._setupPositions();
    this._updateBtnState();
  }

  cycleSelected() {
    this.selectedAnchor = (this.selectedAnchor + 1) % this.numAnchors;
    this.showFailure    = false;
    this.failedIdx      = -1;
  }

  toggleFailure() {
    this.showFailure = !this.showFailure;
    if (this.showFailure) {
      this.failedIdx  = this.selectedAnchor;
      this.failFlash  = 2.0;
    } else {
      this.failedIdx = -1;
    }
    document.getElementById('btnFallo').classList.toggle('active', this.showFailure);
  }

  changeMass(delta) {
    this.massKg = Math.max(20, Math.min(500, this.massKg + delta));
  }

  // ── Cálculo ───────────────────────────────────────────────────────

  _recalculate() {
    const W    = this.massKg * G / 1000.0;
    const mp   = [this.MPX, this.MPY];
    this.anchorResults  = computeAnchorForces(this.anchorPositions, mp, W);
    this.failureResults = computeFailureScenario(
      this.anchorPositions, mp, W, this.selectedAnchor);
  }

  // ── Eventos ───────────────────────────────────────────────────────

  _bindEvents() {
    const cv = this.canvas;

    cv.addEventListener('mousedown', e => {
      const { x, y } = this._canvasPos(e);
      for (let i = 0; i < this.numAnchors; i++) {
        const [ax, ay] = this.anchorPositions[i];
        if (Math.hypot(x - ax, y - ay) < 22) {
          this.draggingAnchor = i;
          this.selectedAnchor = i;
          this.showFailure    = false;
          this.failedIdx      = -1;
          document.getElementById('btnFallo').classList.remove('active');
          this.dragOffX = x - ax;
          this.dragOffY = y - ay;
          break;
        }
      }
    });

    cv.addEventListener('mousemove', e => {
      if (this.draggingAnchor < 0) return;
      const { x, y } = this._canvasPos(e);
      let nx = x - this.dragOffX;
      let ny = y - this.dragOffY;
      nx = Math.max(this.SCENE_LEFT + 30, Math.min(nx, this.SCENE_RIGHT - 30));
      ny = Math.max(this.SCENE_TOP + 20,  Math.min(ny, this.MPY - 40));
      this.anchorPositions[this.draggingAnchor] = [nx, ny];
    });

    cv.addEventListener('mouseup',    () => { this.draggingAnchor = -1; });
    cv.addEventListener('mouseleave', () => { this.draggingAnchor = -1; });

    // Touch support
    cv.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0];
      const { x, y } = this._canvasPos(t);
      for (let i = 0; i < this.numAnchors; i++) {
        const [ax, ay] = this.anchorPositions[i];
        if (Math.hypot(x - ax, y - ay) < 28) {
          this.draggingAnchor = i;
          this.selectedAnchor = i;
          this.showFailure    = false;
          this.failedIdx      = -1;
          document.getElementById('btnFallo').classList.remove('active');
          this.dragOffX = x - ax;
          this.dragOffY = y - ay;
          break;
        }
      }
    }, { passive: false });

    cv.addEventListener('touchmove', e => {
      e.preventDefault();
      if (this.draggingAnchor < 0) return;
      const t = e.touches[0];
      const { x, y } = this._canvasPos(t);
      let nx = x - this.dragOffX;
      let ny = y - this.dragOffY;
      nx = Math.max(this.SCENE_LEFT + 30, Math.min(nx, this.SCENE_RIGHT - 30));
      ny = Math.max(this.SCENE_TOP + 20,  Math.min(ny, this.MPY - 40));
      this.anchorPositions[this.draggingAnchor] = [nx, ny];
    }, { passive: false });

    cv.addEventListener('touchend', () => { this.draggingAnchor = -1; });

    // Teclado
    document.addEventListener('keydown', e => {
      this.keysDown[e.code] = true;

      switch (e.code) {
        case 'Tab':
          e.preventDefault();
          this.cycleSelected();
          break;
        case 'Digit3':
          this.setNumAnchors(3);
          break;
        case 'Digit4':
          this.setNumAnchors(4);
          break;
        case 'KeyF':
          this.toggleFailure();
          break;
        case 'KeyW':
          this.changeMass(+10);
          break;
        case 'KeyS':
          this.changeMass(-10);
          break;
        case 'KeyR':
          this.reset();
          break;
        case 'ArrowLeft': case 'ArrowRight':
        case 'ArrowUp':   case 'ArrowDown':
          e.preventDefault();
          break;
      }
    });

    document.addEventListener('keyup', e => {
      delete this.keysDown[e.code];
    });
  }

  _handleArrowKeys() {
    const speed = this.keysDown['ShiftLeft'] || this.keysDown['ShiftRight'] ? 8 : 3;
    const idx = this.selectedAnchor;
    if (idx >= this.numAnchors) return;

    let [ax, ay] = this.anchorPositions[idx];
    let moved = false;

    if (this.keysDown['ArrowLeft'])  { ax -= speed; moved = true; }
    if (this.keysDown['ArrowRight']) { ax += speed; moved = true; }
    if (this.keysDown['ArrowUp'])    { ay -= speed; moved = true; }
    if (this.keysDown['ArrowDown'])  { ay += speed; moved = true; }

    if (moved) {
      ax = Math.max(this.SCENE_LEFT + 30, Math.min(ax, this.SCENE_RIGHT - 30));
      ay = Math.max(this.SCENE_TOP + 20,  Math.min(ay, this.MPY - 40));
      this.anchorPositions[idx] = [ax, ay];
      if (this.showFailure) {
        this.showFailure = false;
        this.failedIdx   = -1;
        document.getElementById('btnFallo').classList.remove('active');
      }
    }
  }

  _canvasPos(e) {
    const r = this.canvas.getBoundingClientRect();
    const scaleX = this.W / r.width;
    const scaleY = this.H / r.height;
    return {
      x: (e.clientX - r.left) * scaleX,
      y: (e.clientY - r.top)  * scaleY,
    };
  }

  // ── Color de tirante según carga ─────────────────────────────────

  _forceColor(pct, nPoints) {
    const ideal = 100.0 / nPoints;
    const ratio = ideal > 0 ? pct / ideal : 1;

    if (ratio <= 1.1)  return C.accent;   // verde
    if (ratio <= 1.5) {
      const t = (ratio - 1.1) / 0.4;
      const r = Math.round(76  + t * (255 - 76));
      const g = Math.round(175 + t * (193 - 175));
      const b = Math.round(80  + t * (7   - 80));
      return `rgb(${r},${g},${b})`;
    }
    if (ratio <= 2.0) {
      const t = (ratio - 1.5) / 0.5;
      const g = Math.round(193 - t * 193);
      return `rgb(255,${g},0)`;
    }
    return C.danger;
  }

  // ── Dibujo canvas ────────────────────────────────────────────────

  _drawRockFace() {
    const ctx = this.ctx;
    const { SCENE_LEFT: sl, SCENE_RIGHT: sr, SCENE_TOP: st } = this;
    const rockH = 220; // altura de la zona de roca

    ctx.save();
    // Fondo de roca
    ctx.fillStyle = '#23233a';
    this._roundRect(sl, st, sr - sl, rockH, 10);
    ctx.fill();

    // Textura horizontal sutil
    ctx.strokeStyle = '#2a2a46';
    ctx.lineWidth = 1;
    for (let y = st + 15; y < st + rockH; y += 28) {
      const xStart = sl + 10 + (y * 7) % 30;
      const xEnd   = sr - 10 - (y * 11) % 40;
      ctx.beginPath();
      ctx.moveTo(xStart, y);
      ctx.lineTo(xEnd, y);
      ctx.stroke();
    }

    // Grietas verticales
    ctx.strokeStyle = '#2d2d48';
    for (let x = sl + 60; x < sr - 60; x += 95) {
      const yStart = st + 20 + (x * 3) % 50;
      const yEnd   = Math.min(yStart + 120 + (x * 7) % 80, st + rockH - 30);
      ctx.beginPath();
      ctx.moveTo(x, yStart);
      ctx.lineTo(x + 5, yEnd);
      ctx.stroke();
    }

    // Borde
    ctx.strokeStyle = C.anchor;
    ctx.lineWidth = 2;
    this._roundRect(sl, st, sr - sl, rockH, 10);
    ctx.stroke();

    // Etiqueta
    ctx.fillStyle = C.anchor;
    ctx.font = '11px "Segoe UI", sans-serif';
    ctx.fillText('PARED DE ROCA', sl + 10, st + 18);

    ctx.restore();
  }

  _roundRect(x, y, w, h, r) {
    const ctx = this.ctx;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y,     x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x,     y + h, r);
    ctx.arcTo(x,     y + h, x,     y,     r);
    ctx.arcTo(x,     y,     x + w, y,     r);
    ctx.closePath();
  }

  _drawVerticalReference() {
    const ctx = this.ctx;
    const mx = this.MPX, my = this.MPY;
    ctx.save();
    ctx.setLineDash([8, 8]);
    ctx.strokeStyle = '#3c3c5a';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(mx, this.SCENE_TOP + 20);
    ctx.lineTo(mx, my);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#3c3c5a';
    ctx.font = '10px "Segoe UI", sans-serif';
    ctx.fillText('Vertical', mx + 5, this.SCENE_TOP + 36);
    ctx.restore();
  }

  _drawDashedLine(x1, y1, x2, y2, color, width, dashLen) {
    const ctx = this.ctx;
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len < 1) return;
    const ux = dx / len, uy = dy / len;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth   = width;
    let pos = 0, drawing = true;
    while (pos < len) {
      const end = Math.min(pos + dashLen, len);
      if (drawing) {
        ctx.beginPath();
        ctx.moveTo(x1 + ux * pos,  y1 + uy * pos);
        ctx.lineTo(x1 + ux * end,  y1 + uy * end);
        ctx.stroke();
      }
      pos = end + dashLen / 2;
      drawing = !drawing;
    }
    ctx.restore();
  }

  _drawForceArrow(ax, ay, mx, my, forceKN, color) {
    const ctx = this.ctx;
    const dx = ax - mx, dy = ay - my;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len < 10) return;
    const ux = dx / len, uy = dy / len;

    const arrowLen = Math.min(30 + forceKN * 15, len * 0.35);
    const sx = ax - ux * 25;
    const sy = ay - uy * 25;
    const ex = sx - ux * arrowLen;
    const ey = sy - uy * arrowLen;

    const headSize = 8;
    const px = -uy * headSize, py = ux * headSize;
    const tx = ex - ux * headSize, ty = ey - uy * headSize;

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle   = color;
    ctx.lineWidth   = 3;

    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(ex, ey);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(ex, ey);
    ctx.lineTo(tx + px, ty + py);
    ctx.lineTo(tx - px, ty - py);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  _drawAngleArc(r) {
    const ctx = this.ctx;
    const [ax, ay] = r.pos;
    const mx = this.MPX, my = this.MPY;
    const alpha = r.alphaDeg;
    if (alpha < 2) return;

    const arcRadius = 38;
    const dx = ax - mx, dy = my - ay;
    const slingAngle = Math.atan2(dx, dy); // desde vertical

    const nPts = Math.max(Math.round(alpha / 2), 8);
    ctx.save();
    ctx.strokeStyle = ANCHOR_COLORS[r.index % 4];
    ctx.lineWidth   = 1;
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    for (let k = 0; k <= nPts; k++) {
      const t = k / nPts;
      const a = t * slingAngle;
      const px = mx + arcRadius * Math.sin(a);
      const py = my - arcRadius * Math.cos(a);
      k === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.stroke();
    ctx.restore();
  }

  _drawSlingsAndForces() {
    const ctx = this.ctx;
    const mx = this.MPX, my = this.MPY;
    const results = this.anchorResults;

    results.forEach(r => {
      const [ax, ay] = r.pos;
      const isFailed = this.showFailure && r.index === this.failedIdx;

      if (isFailed) {
        this._drawDashedLine(ax, ay, mx, my, C.danger, 2, 8);
        return;
      }

      let forceColor = this._forceColor(r.pct, this.numAnchors);

      if (this.showFailure && this.failureResults.length) {
        const fr = this.failureResults.find(f => f.index === r.index && !f.failed);
        if (fr) forceColor = this._forceColor(fr.pct, this.numAnchors - 1);
      }

      const lineW = Math.max(2, Math.min(Math.round(r.pct / 10), 6));

      ctx.save();
      ctx.strokeStyle = forceColor;
      ctx.lineWidth   = lineW;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(mx, my);
      ctx.stroke();
      ctx.restore();

      this._drawForceArrow(ax, ay, mx, my, r.forceKN, forceColor);

      // Etiqueta en el punto medio
      const midX = (ax + mx) / 2;
      const midY = (ay + my) / 2;
      const ddx = mx - ax, ddy = my - ay;
      const dLen = Math.sqrt(ddx*ddx + ddy*ddy);
      const nx = dLen > 0 ? -ddy / dLen * 22 : 22;
      const ny = dLen > 0 ?  ddx / dLen * 22 : 0;

      const line1 = `${r.alphaDeg.toFixed(1)}°`;
      const line2 = `${r.forceKN.toFixed(2)} kN`;

      ctx.save();
      ctx.font      = '11px "Segoe UI", monospace';
      const w1 = ctx.measureText(line1).width;
      const w2 = ctx.measureText(line2).width;
      const bw = Math.max(w1, w2) + 8;
      const bh = 28;
      const lx = midX + nx - bw / 2;
      const ly = midY + ny - bh / 2;

      ctx.fillStyle = 'rgba(15,15,26,0.82)';
      this._roundRect(lx, ly, bw, bh, 3);
      ctx.fill();

      ctx.fillStyle = C.dark_text;
      ctx.fillText(line1, lx + 4, ly + 12);
      ctx.fillStyle = forceColor;
      ctx.fillText(line2, lx + 4, ly + 24);
      ctx.restore();

      // Arco de ángulo
      this._drawAngleArc(r);
    });
  }

  _drawAnchorBolts() {
    const ctx = this.ctx;

    for (let i = 0; i < this.numAnchors; i++) {
      const [ax, ay]   = this.anchorPositions[i];
      const isSel      = i === this.selectedAnchor;
      const isFailed   = this.showFailure && i === this.failedIdx;
      let color        = ANCHOR_COLORS[i % 4];

      if (isFailed) {
        const flash = Math.sin(this.failFlash * 8) > 0;
        color = flash ? C.danger : '#641e1e';
      }

      const boltR = isSel ? 14 : 10;

      // Sombra/base
      ctx.save();
      ctx.fillStyle = '#505068';
      ctx.beginPath();
      ctx.arc(ax, ay, boltR + 4, 0, Math.PI * 2);
      ctx.fill();

      // Círculo exterior
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(ax, ay, boltR, 0, Math.PI * 2);
      ctx.fill();

      // Agujero interior
      ctx.fillStyle = isFailed ? C.danger : C.bg;
      ctx.beginPath();
      ctx.arc(ax, ay, Math.max(boltR - 4, 3), 0, Math.PI * 2);
      ctx.fill();

      // Borde de selección
      if (isSel && !isFailed) {
        ctx.strokeStyle = C.white;
        ctx.lineWidth   = 2;
        ctx.beginPath();
        ctx.arc(ax, ay, boltR + 7, 0, Math.PI * 2);
        ctx.stroke();

        // Flecha indicadora
        ctx.fillStyle = C.white;
        ctx.beginPath();
        ctx.moveTo(ax,     ay - boltR - 12);
        ctx.lineTo(ax - 6, ay - boltR - 20);
        ctx.lineTo(ax + 6, ay - boltR - 20);
        ctx.closePath();
        ctx.fill();
      }

      // X de fallo
      if (isFailed) {
        const s = boltR + 6;
        ctx.strokeStyle = C.danger;
        ctx.lineWidth   = 4;
        ctx.beginPath();
        ctx.moveTo(ax - s, ay - s); ctx.lineTo(ax + s, ay + s);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ax + s, ay - s); ctx.lineTo(ax - s, ay + s);
        ctx.stroke();
      }

      // Etiqueta
      let label = ANCHOR_LABELS[i];
      if (isFailed) label += ' FALLO';
      const labelY = isSel ? ay - boltR - 36 : ay - boltR - 26;
      ctx.fillStyle = color;
      ctx.font = 'bold 13px "Segoe UI", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(label, ax, labelY);

      ctx.restore();
    }
  }

  _drawMasterPoint() {
    const ctx = this.ctx;
    const mx = this.MPX, my = this.MPY;
    ctx.save();

    // Anillo de ecualizacion
    ctx.strokeStyle = C.warning;
    ctx.fillStyle   = C.bg;
    ctx.lineWidth   = 3;
    ctx.beginPath();
    ctx.arc(mx, my, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // Punto central
    ctx.fillStyle = C.warning;
    ctx.beginPath();
    ctx.arc(mx, my, 4, 0, Math.PI * 2);
    ctx.fill();

    // Etiqueta
    ctx.fillStyle   = C.warning;
    ctx.font        = '11px "Segoe UI", sans-serif';
    ctx.textAlign   = 'center';
    ctx.fillText('PUNTO MAESTRO', mx, my + 30);

    ctx.restore();
  }

  _drawLoad() {
    const ctx  = this.ctx;
    const mx   = this.MPX, my = this.MPY;
    const W_kN = this.massKg * G / 1000.0;

    const loadTop = my + 16;
    const loadY   = my + 75;
    const lw = 64, lh = 36;

    ctx.save();

    // Cuerda
    ctx.strokeStyle = C.rope;
    ctx.lineWidth   = 3;
    ctx.beginPath();
    ctx.moveTo(mx, loadTop);
    ctx.lineTo(mx, loadY - 12);
    ctx.stroke();

    // Mosquetón
    ctx.fillStyle = C.anchor;
    ctx.beginPath();
    ctx.arc(mx, loadY - 9, 5, 0, Math.PI * 2);
    ctx.fill();

    // Caja de carga
    ctx.fillStyle   = C.secondary;
    ctx.strokeStyle = C.text;
    ctx.lineWidth   = 2;
    this._roundRect(mx - lw/2, loadY, lw, lh, 5);
    ctx.fill();
    ctx.stroke();

    // Icono persona simplificado
    ctx.fillStyle   = C.primary;
    ctx.strokeStyle = C.primary;
    ctx.lineWidth   = 2;
    ctx.beginPath();
    ctx.arc(mx - 12, loadY + 11, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(mx - 12, loadY + 16);
    ctx.lineTo(mx - 12, loadY + 30);
    ctx.stroke();

    // Texto de masa
    ctx.fillStyle = C.text;
    ctx.font      = 'bold 12px "Segoe UI", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`${this.massKg} kg`, mx + 2, loadY + lh/2 + 5);

    // Flecha de peso
    const arrowTop    = loadY + lh + 6;
    const arrowBottom = arrowTop + 36;
    ctx.strokeStyle = C.danger;
    ctx.lineWidth   = 3;
    ctx.beginPath();
    ctx.moveTo(mx, arrowTop);
    ctx.lineTo(mx, arrowBottom);
    ctx.stroke();
    ctx.fillStyle = C.danger;
    ctx.beginPath();
    ctx.moveTo(mx,     arrowBottom + 7);
    ctx.lineTo(mx - 5, arrowBottom);
    ctx.lineTo(mx + 5, arrowBottom);
    ctx.closePath();
    ctx.fill();

    // Etiqueta W
    ctx.fillStyle = C.danger;
    ctx.font      = 'bold 12px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`W = ${W_kN.toFixed(2)} kN`, mx, arrowBottom + 18);

    ctx.restore();
  }

  _drawSafetyStatus() {
    const ctx = this.ctx;
    let maxPct = 0, maxAngle = 0;
    this.anchorResults.forEach(r => {
      if (r.pct      > maxPct)   maxPct   = r.pct;
      if (r.alphaDeg > maxAngle) maxAngle = r.alphaDeg;
    });

    const ideal = 100.0 / this.numAnchors;
    const ratio = ideal > 0 ? maxPct / ideal : 99;

    let status, color;
    if (this.showFailure) {
      status = `FALLO DE ${ANCHOR_LABELS[this.failedIdx]} — REDISTRIBUCIÓN`;
      color  = C.danger;
    } else if (ratio <= 1.2 && maxAngle <= 45) {
      status = 'DISTRIBUCIÓN EQUILIBRADA';
      color  = C.accent;
    } else if (ratio <= 1.5 && maxAngle <= 60) {
      status = 'DISTRIBUCIÓN ACEPTABLE';
      color  = C.warning;
    } else if (maxAngle > 75) {
      status = 'ÁNGULO EXCESIVO — REDISTRIBUIR';
      color  = C.danger;
    } else {
      status = 'DISTRIBUCIÓN DESBALANCEADA';
      color  = C.danger;
    }

    ctx.save();
    ctx.font = 'bold 12px "Segoe UI", sans-serif';
    const tw = ctx.measureText(status).width;
    const bw = tw + 22, bh = 24;
    const bx = this.SCENE_LEFT + 10;
    const by = this.SCENE_BOTTOM - 52;

    ctx.fillStyle   = C.bg;
    ctx.strokeStyle = color;
    ctx.lineWidth   = 2;
    this._roundRect(bx, by, bw, bh, 5);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = color;
    ctx.textAlign = 'left';
    ctx.fillText(status, bx + 11, by + 16);
    ctx.restore();
  }

  _drawTitle() {
    const ctx = this.ctx;
    ctx.save();
    ctx.fillStyle = C.primary;
    ctx.font      = 'bold 18px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('DISTRIBUCIÓN MULTI-ANCLAJE', this.W / 2, 26);
    ctx.fillStyle = C.dark_text;
    ctx.font      = '12px "Segoe UI", sans-serif';
    ctx.fillText(
      `Sistema auto-ecualizado de ${this.numAnchors} puntos`,
      this.W / 2, 46);
    ctx.restore();
  }

  // ── Render principal ─────────────────────────────────────────────

  _render() {
    const ctx = this.ctx;
    ctx.clearRect(0, 0, this.W, this.H);

    // Fondo
    ctx.fillStyle = C.bg;
    ctx.fillRect(0, 0, this.W, this.H);

    this._drawTitle();
    this._drawRockFace();
    this._drawVerticalReference();
    this._drawSlingsAndForces();
    this._drawAnchorBolts();
    this._drawMasterPoint();
    this._drawLoad();
    this._drawSafetyStatus();
  }

  // ── Actualizar panel lateral ─────────────────────────────────────

  _updatePanel() {
    const W_kN = this.massKg * G / 1000.0;

    document.getElementById('pMasa').textContent      = `${this.massKg} kg`;
    document.getElementById('pPeso').textContent      = `${W_kN.toFixed(3)} kN`;
    document.getElementById('pNAnclajes').textContent = `${this.numAnchors}`;
    document.getElementById('pSeleccionado').textContent = ANCHOR_LABELS[this.selectedAnchor];
    document.getElementById('pIdeal').textContent     =
      `${(100 / this.numAnchors).toFixed(1)}% c/u`;

    // Tabla de anclajes
    const tbody = document.getElementById('anchorTableBody');
    tbody.innerHTML = '';
    this.anchorResults.forEach(r => {
      const isFailed = this.showFailure && r.index === this.failedIdx;
      const isSel    = r.index === this.selectedAnchor;
      const color    = ANCHOR_COLORS[r.index % 4];

      if (isFailed) {
        const tr = document.createElement('tr');
        tr.style.opacity = '0.5';
        tr.innerHTML = `
          <td style="color:${C.danger};font-weight:bold">${ANCHOR_LABELS[r.index]}</td>
          <td colspan="5" style="color:${C.danger}">— FALLO —</td>`;
        tbody.appendChild(tr);
        return;
      }

      const T  = slingTension(r.forceKN, r.alphaDeg);
      const sf = T > 0.001 ? ANCHOR_MBS / T : 999;
      let statusText, statusClass;
      if (sf >= 10)      { statusText = 'OK';        statusClass = 'status-ok'; }
      else if (sf >= 5)  { statusText = 'PRECAUCIÓN'; statusClass = 'status-caution'; }
      else               { statusText = 'PELIGRO';   statusClass = 'status-danger'; }

      const fColor = this._forceColor(r.pct, this.numAnchors);

      const tr = document.createElement('tr');
      if (isSel) tr.style.outline = `1px solid ${color}`;
      tr.innerHTML = `
        <td style="color:${color};font-weight:bold">${ANCHOR_LABELS[r.index]}</td>
        <td>${r.alphaDeg.toFixed(1)}</td>
        <td style="color:${fColor}">${r.forceKN.toFixed(2)}</td>
        <td style="color:${fColor}">${r.pct.toFixed(1)}</td>
        <td>${T.toFixed(2)}</td>
        <td class="${statusClass}">${statusText}</td>`;
      tbody.appendChild(tr);
    });

    // Gráfico de barras
    const barDiv = document.getElementById('barChart');
    barDiv.innerHTML = '';
    const ideal = 100.0 / this.numAnchors;

    this.anchorResults.forEach(r => {
      const isFailed = this.showFailure && r.index === this.failedIdx;
      const color    = ANCHOR_COLORS[r.index % 4];

      let failPct = null;
      if (this.showFailure && this.failureResults.length) {
        const fr = this.failureResults.find(f => f.index === r.index && !f.failed);
        if (fr) failPct = fr.pct;
      }

      const fColor = isFailed ? C.danger : this._forceColor(r.pct, this.numAnchors);
      const pctVal = isFailed ? 0 : r.pct;

      const row = document.createElement('div');
      row.className = 'bar-row';
      row.innerHTML = `
        <span class="bar-label" style="color:${color}">${ANCHOR_LABELS[r.index]}</span>
        <div class="bar-track">
          <div class="bar-fill" style="width:${Math.min(pctVal,100)}%;background:${fColor}"></div>
          <div class="bar-ideal-line" style="left:${ideal}%"></div>
          ${failPct !== null ? `<div style="position:absolute;top:0;left:0;height:100%;width:${Math.min(failPct,100)}%;border:2px solid ${C.danger};border-radius:3px;box-sizing:border-box"></div>` : ''}
        </div>
        <span class="bar-pct" style="color:${fColor}">
          ${isFailed ? 'FALLO' : pctVal.toFixed(1)+'%'
          }${failPct !== null ? ` → ${failPct.toFixed(1)}%` : ''}
        </span>`;
      barDiv.appendChild(row);
    });

    // Leyenda ideal
    const leg = document.createElement('div');
    leg.style.cssText = 'font-size:0.72rem;color:#546E7A;margin-top:2px';
    leg.textContent   = `| = ideal (${ideal.toFixed(0)}%)`;
    barDiv.appendChild(leg);

    // Análisis de fallo
    const failDiv   = document.getElementById('failureAnalysis');
    const failTitle = document.getElementById('failTitle');
    failTitle.textContent = `Si ${ANCHOR_LABELS[this.selectedAnchor]} falla:`;
    failDiv.innerHTML     = '';

    const remaining = this.numAnchors - 1;
    if (remaining < 1) {
      failDiv.innerHTML = `<span style="color:${C.danger}">Sistema colapsa sin anclajes restantes.</span>`;
    } else {
      let maxForce = 0;
      this.failureResults.forEach(fr => {
        if (!fr.failed && fr.forceKN > maxForce) maxForce = fr.forceKN;
      });

      this.failureResults.forEach(fr => {
        if (fr.failed) return;
        const orig = this.anchorResults.find(r => r.index === fr.index);
        const origStr = orig ? orig.forceKN.toFixed(2) : '?';
        const fc = this._forceColor(fr.pct, remaining);
        const row = document.createElement('div');
        row.className = 'fail-row';
        row.innerHTML = `
          <span style="color:${ANCHOR_COLORS[fr.index%4]}">${ANCHOR_LABELS[fr.index]}</span>
          <span style="color:${C.dark_text}">${origStr} → <span style="color:${fc}">${fr.forceKN.toFixed(2)} kN (${fr.pct.toFixed(1)}%)</span></span>`;
        failDiv.appendChild(row);
      });

      const shock = maxForce * SHOCK_FACTOR;
      const shockRow = document.createElement('div');
      shockRow.style.cssText = `font-size:0.76rem;color:${C.danger};margin-top:4px`;
      shockRow.textContent   = `Carga de choque (×${SHOCK_FACTOR}): ${shock.toFixed(2)} kN`;
      failDiv.appendChild(shockRow);

      if (shock > ANCHOR_MBS) {
        const warn = document.createElement('div');
        warn.style.cssText = `font-size:0.75rem;color:${C.danger};font-weight:bold`;
        warn.textContent   = 'SUPERA resistencia del anclaje! Fallo en cascada posible.';
        failDiv.appendChild(warn);
      } else if (maxForce > NFPA) {
        const warn = document.createElement('div');
        warn.style.cssText = `font-size:0.75rem;color:${C.warning}`;
        warn.textContent   = 'Supera carga de trabajo NFPA (13.5 kN).';
        failDiv.appendChild(warn);
      }
    }

    // Status badge
    let maxPct = 0, maxAngle = 0;
    this.anchorResults.forEach(r => {
      if (r.pct      > maxPct)   maxPct   = r.pct;
      if (r.alphaDeg > maxAngle) maxAngle = r.alphaDeg;
    });
    const ideal2 = 100.0 / this.numAnchors;
    const ratio  = ideal2 > 0 ? maxPct / ideal2 : 99;

    let badgeText, badgeColor;
    if (this.showFailure) {
      badgeText  = `FALLO DE ${ANCHOR_LABELS[this.failedIdx]} — REDISTRIBUCIÓN`;
      badgeColor = C.danger;
    } else if (ratio <= 1.2 && maxAngle <= 45) {
      badgeText  = 'DISTRIBUCIÓN EQUILIBRADA';
      badgeColor = C.accent;
    } else if (ratio <= 1.5 && maxAngle <= 60) {
      badgeText  = 'DISTRIBUCIÓN ACEPTABLE';
      badgeColor = C.warning;
    } else if (maxAngle > 75) {
      badgeText  = 'ÁNGULO EXCESIVO — REDISTRIBUIR';
      badgeColor = C.danger;
    } else {
      badgeText  = 'DISTRIBUCIÓN DESBALANCEADA';
      badgeColor = C.danger;
    }

    const badge = document.getElementById('statusBadge');
    badge.textContent         = badgeText;
    badge.style.color         = badgeColor;
    badge.style.borderColor   = badgeColor;
    badge.style.background    = `${badgeColor}14`;
  }

  _updateBtnState() {
    document.getElementById('btn3').classList.toggle('selected-3', this.numAnchors === 3);
    document.getElementById('btn4').classList.toggle('selected-4', this.numAnchors === 4);
  }

  // ── Loop principal ───────────────────────────────────────────────

  _loop() {
    let last = performance.now();

    const tick = (now) => {
      const dt = Math.min((now - last) / 1000, 0.1);
      last = now;

      this._handleArrowKeys();
      this._recalculate();

      if (this.failFlash > 0) this.failFlash -= dt;

      this._render();
      this._updatePanel();
      this._updateBtnState();

      requestAnimationFrame(tick);
    };

    requestAnimationFrame(tick);
  }
}

// ── Arrancar ──────────────────────────────────────────────────────────
const sim = new MultiAnchorSim('simCanvas');
</script>

          </div><!-- /.sim-content -->
        </div>
      </div><!-- /.cover -->
    </div><!-- /.container -->
  </div><!-- /.page-content -->

  <footer class="site-footer d-print-none">
    <div class="container text-center">
      <p>&copy; <span id="footer-year"></span> Jorge A. Balsells Orellana. All rights reserved.</p>
    </div>
  </footer>

  <button class="back-to-top d-print-none" id="backToTop" aria-label="Back to top">
    <i class="fas fa-chevron-up"></i>
  </button>

  <script>
/* ── Responsive canvas scaling ─────────────────────────────── */
(function () {
  var s = document.querySelector('.canvas-row, .main-layout, .main-row');
  if (!s) return;
  function init() {
    var _saved = s.style.minWidth;
    s.style.minWidth = 'max-content';
    var nW = s.offsetWidth, nH = s.offsetHeight;
    s.style.minWidth = _saved;
    if (!nW) return;
    var w = document.createElement('div');
    w.style.cssText = 'width:100%;overflow:hidden;';
    s.parentNode.insertBefore(w, s);
    w.appendChild(s);
    function rescale() {
      var a = w.clientWidth;
      if (a > 0 && a < nW) {
        var sc = a / nW;
        s.style.transformOrigin = 'top left';
        s.style.transform = 'scale(' + sc + ')';
        w.style.height = Math.ceil(nH * sc) + 'px';
      } else {
        s.style.transform = '';
        w.style.height = '';
      }
    }
    window.addEventListener('resize', rescale);
    rescale();
  }
  if (document.readyState === 'complete') { init(); }
  else { window.addEventListener('load', init); }
})();
</script>
<script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="../scripts/aos.js"></script>
  <script src="../scripts/main.js"></script>

</body>
</html>
